# Circling - проблема циклической зависимости

Задача возникла при просмотре видео 
[Евгений Борисов — Spring – Глубоко и не очень](https://youtu.be/nGfeSo52_8A). Данный проект - это
некий playground для того, чтобы руками пощупать, что, как и где может или не может использоваться. 

## Stage 1. Spring DI без циклических зависимостей

Бин Husband с двумя зависимыми бинами Pet и Car. Рассмотрены DI через конструктор и через аннотацию @Autowired.
Закомментирован вызов Husband -> Car в конструкторе, приводящий к NullPointerException. 

## Stage 2. Spring DI с циклическими зависимостями

### Stage 2.1 DI в конструкторах

Если инжектить циклически зависимые бины через конструктор, то получаем UnsatisfiedDependencyException. 
Это вполне ожидаемое поведение.

### Stage 2.2 @Autowired

DI циклически зависимых бинов через @Autowired. Бины выполняют только "быстрые" взаимодействия, так как
вызовы "медленных" методов будут выполняться в общем потоке Spring'а и тормозить старт приложения. 

### Stage 2.3 Вызов медленных сервисных методов

"Тяжёлую" бизнес-логику сервисов имеет смысл использовать при получении ContextStartedEvent. Событие генерируется при
вызове context.start() в main(). Проблема в том, что всё это работает в одном потоке, и пока бизнес-логика по
ContextStartedEvent не завершит свою работу, код в main() не продолжит выполняться. 

## Stage 3. Spring Integration

### Stage 3.1 Пробуем @Async
 
Добавляем:
* Spring Integration и @Async в наш проект
* новый неиспользуемый @Async-метод в бин John

При запуске приложения получаем BeanCurrentlyInCreationException. Это происходит в методе 
doCreateBean класса AbstractAutowireCapableBeanFactory на этапе пост-обработки бина John
после всех BeanPostProcessor'ов (проверьте дебаггером начиная с последней инструкции 
John.onPostConstruct()).     

### Stage 3.2 Избавляемся от @Autowired в циклических зависимостях

Пробуем реализовать workaround для @Autowired в циклических зависимостях. Дополнительная сущность Family будет
инжектить их самостоятельно используя DI в конструкторе. При запуске появляется еще одно исключение о том, что 
медоды с аннотацией @EventListener класса StatedBean не могут быть обёрнуты в прокси у наследников. К счастью,
детальную работу этих методов показали прошлые этапы, поэтому они были исключены из дальнейших реализаций. Пробуем
вызывать "медленную" бизнесс-логику из Family. Всё работает. Наконец-то можно переходить к заключительным этапам. 

### Stage 3.3 @Async is working !!!

Все медленные методы помечены @Async. Управление worker-сервисами отдано на откуп Spring'у имплементацией интерфейса
 Lifecycle у всех Essence. В этом случае не нужно слушать event'ы ContextStartedEvent & ContextStoppedEvent, 
 нужно уметь реагировать на команды Lifecycle.