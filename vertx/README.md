# vertx

Песочница для Eclipse Vert.x. Показаны этапы развития проекта от имеративного подхода к реактивному с 
использованием фреймворка Vert.x

## Stage 1. Императивный подход к проектированию приложений

`Client` при запуске приложения начинает периодически (200 мс) опрашивать данные об изменении курсов валют, используя 
бин `RatesService`, и визуализирует данные в лог. Сервис использует набор репозиториев (по одному на соответствующую 
валюту). Всё работает, но... 
 
Клиент хочет получать данные сразу, как только они появляются в системе. Периодические запросы гарантируют максимальную
задержку, равную периоду опроса. Уменьшать бесконечно период опроса - тупиковый вариант, так как планируется
имплементация дополнительных клиентов (потребителей данных) и валют (источников данных).

## Stage 2. Переходим на Eclipse Vert.x

Код проекта претерпел небольшие изменения:

* Добавлен механизм `application.properties` для инжекции конфигурационных параметров

* Класс `Config` объявляет дополнительные бины `Vertx` и `RateMessageCodec` для использования `EventBus` в качестве
локальной шины обмена сообщениями/событиями типа `Rate`. 

* Код `Client` и `LogUsdClient` претерпел небольшие изменения, связанные с переходом на подписку новых событий.
 
* Сервис-посредник (`RatesService` / `RatesServiceImpl`) оказывается ненужным, т.к. пока что не несёт полезной нагрузки
в виде бизнес-логики, а отсутствие зависимости клиента от dataSource-репозиториев теперь обеспечивает `EventBus`.
Агрегирование источников с котировками так же перекладывается на плечи `EventBus`, поэтому от исходного 
текста сервиса остаются только заглушки на будущее (пакет `service` в целом не нужен).

* Пакет `repository` претерпевает значительные изменения, так как интерфейс репизиториев значительно сокращается
(предыдущие ограничения на моновалютную реализацию репозитория могут быть сняты). Класс `UsdRatesRepository` немного 
изменился, поменяв базовый класс и обеспечивая генерацию событий новых котировок.

В итоге клиент получает новые события по мере их поступления, задержка в получении обусловлена только выбранным 
фреймворком для реализации шины событий. 

## Stage 3. Аннотированая интерация со Spring'ом

Попытка избежать дублированного кода в проектах с Vert.x. Идея состоит в том, чтобы проаннотировать класс конфигурации
и магическим образом получить автодеплой вертикалей. При этом автоматически должен подключаться бин Vertx в контекст
Spring'а, а проаннторированные особым образом бины распознавались бы как вертикали для последующего автодеплоя после 
окончательной сборки контекста. При этом естественно нужно обеспечить полноту вариантов деплоя вертикалей: вертикали
должны содержать поле типа `DeploymentOptions` с параметрами для своего деплоя в случае необходимости, а так же методы 
для callback'ов в случае успешного/неуспешного деплоя вертикали.  

Добавлены аннотации:

* `@VertX` для [класса конфигурации](src/main/java/info/kupchenko/sandbox/spring/vertx/Config.java) -
добавляет бин Vertx в контекст и обеспечивает функционирование остальных аннотаций
* `@Vertical` для аннотирования [наследников класса](src/main/java/info/kupchenko/sandbox/spring/vertx/repository/EurRatesRepository.java)
`AbstractVerticle` - позволяет производить автодеплой 
маркированных вертикалей
* `@DeployOptions` для аннотирования экземпляра класса `DeploymentOptions` - позволяет указывать опции деплоя вертикали
* `@OnDeploySuccess` для метода класса вертикали - позволяет вызывать callback при успешном деплое вертикали
* `@OnDeployError` для метода класса вертикали - позволяет вызывать callback при неуспешном деплое вертикали

Недостатки: воркер-вертикали деплоятся в отдельный пул нитей, callback'и на них пока не работают. Необходима дальнейшая
проработка данного направления, а так же тестирование в случае вертикалей-прототипов. Пока функциональность 
протестирована только на синглтонах. В случае успешного решения вопроса по callback'ам у воркеров имеет смысл оформить 
данный функционал в виде отдельной библиотеки.